ğŸ§± PHASE 0: PROJECT SKELETON, LEGAL GOVERNANCE & PREFLIGHT

Role: Lead Architect & Security Compliance Officer
Target Environment: Linux (Ubuntu 22.04+ / RHEL 8+)
Root Path: /home/ransomeye/rebuild/

1. ğŸ›‘ CRITICAL ARCHITECTURAL CONSTRAINTS

Monorepo Structure: Use a Rust Workspace. Every crate directory and crate name MUST start with ransomeye_.

Fail-Closed Governance: The build tools created here must exit with exit(1) if any violation (GPL license, missing header, or low swap) is detected.

No Exceptions: Do not use unwrap() or expect() in the governance tools; implement proper error handling with anyhow or thiserror.

2. ğŸ“‚ DIRECTORY STRUCTURE TO CREATE

/home/ransomeye/rebuild/
â”œâ”€â”€ .gitignore                  # Standard Rust/Node gitignore + .env
â”œâ”€â”€ Cargo.toml                  # Workspace Root Manifest
â”œâ”€â”€ governance/
â”‚   â””â”€â”€ ransomeye_governor_tools/
â”‚       â”œâ”€â”€ Cargo.toml
â”‚       â””â”€â”€ src/
â”‚           â””â”€â”€ bin/
â”‚               â”œâ”€â”€ license_check.rs # Dependency Auditor
â”‚               â”œâ”€â”€ header_check.rs  # Copyright Header Enforcer
â”‚               â””â”€â”€ preflight.rs     # 16GB Swap & Resource Verifier
â”œâ”€â”€ core/                       # (Placeholder for backend crates)
â”œâ”€â”€ edge/                       # (Placeholder for agent/probe crates)
â”œâ”€â”€ ops/                        # (Placeholder for SRE crates)
â””â”€â”€ ui/                         # (Placeholder for console/wasm crates)


3. âš™ï¸ COMPONENT SPECIFICATIONS

A. Root Workspace (Cargo.toml)

Resolver: 2

Members: "governance/ransomeye_governor_tools", "core/ransomeye_kernel", "core/ransomeye_bus", "core/ransomeye_db", "core/ransomeye_api", "core/ransomeye_intel", "core/ransomeye_ingest", "core/ransomeye_engine", "core/ransomeye_policy", "core/ransomeye_dispatch", "core/ransomeye_ai", "core/ransomeye_forensics", "core/ransomeye_narrative", "core/ransomeye_governor", "core/ransomeye_threat_feed", "core/ransomeye_trainer", "core/ransomeye_audit", "core/ransomeye_server", "edge/ransomeye_agent", "edge/ransomeye_dpi", "edge/ransomeye_sentinel", "edge/ransomeye_loader", "ops/ransomeye_tuner", "ops/ransomeye_portguard", "ops/ransomeye_ops_cli", "ui/ransomeye_wasm"

B. Governor Tools (governance/ransomeye_governor_tools/Cargo.toml)

Dependencies:

cargo_metadata = "0.23" (For dependency tree auditing)

toml = "0.8" (For manifest parsing)

walkdir = "2.5" (For header scanning)

colored = "3.0" (For terminal feedback)

sysinfo = "0.33" (For hardware/swap verification)

C. Tool Logic: license_check.rs

Initialize cargo_metadata::MetadataCommand.

Iterate through every package in the workspace and their dependencies.

Blocked List: If package.license contains GPL, AGPL, SSPL, or Commons Clause, print a RED [VIOLATION] message with the package name and exit with code 1.

Clean: If all pass, print GREEN [PASSED] Legal Compliance.

D. Tool Logic: header_check.rs

Target Header: // Copyright (c) RansomEye. Proprietary & Confidential.

Scan root recursively for files ending in .rs, .ts, .tsx, .py.

Verify the first line matches the target header exactly.

Failure: Exit with code 1 and list all offending files in Red.

E. Tool Logic: preflight.rs

Swap Check: Use sysinfo to verify total_swap. If < 16,000,000,000 (16GB), print [CRITICAL] System requires 16GB SWAP for production stability and exit 1.

Permission Check: Verify write access to /home/ransomeye/rebuild/.

Tool Check: Verify cargo and npm are in the PATH.

4. âœ… ACCEPTANCE CRITERIA FOR CURSOR

Running cargo build at the root succeeds.

The directory names and Cargo.toml names are perfectly aligned with the ransomeye_ prefix.

Running cargo run --bin preflight successfully detects if the system meets the 16GB swap requirement.

Running cargo run --bin header_check fails if a new file is added without the RansomEye copyright.

----------------------

ğŸ”‘ PHASE 1: CORE KERNEL & AUTHENTICATION (TRUST ROOT)

Role: Senior Systems Engineer & Cryptography Architect
Target Path: /home/ransomeye/rebuild/core/ransomeye_kernel/
Goal: Build the ransomeye_kernel library, providing the foundation for Configuration, Logging, Cryptography (Ed25519), and Authentication (JWT/Argon2).

1. ğŸ›‘ HARD CONSTRAINTS (MUST OBEY)

Naming Convention: Crate name MUST be ransomeye_kernel.

Fail-Closed Configuration: If RE_TRUST_ROOT_KEY or RE_DB_URL are missing from the environment, the application MUST panic during initialization.

Zero-Trust Logging: All logs must be structured JSON (via tracing-subscriber) to stdout.

No unwrap(): Use thiserror for all kernel-level errors.

2. ğŸ“‚ DIRECTORY STRUCTURE

core/ransomeye_kernel/
â”œâ”€â”€ Cargo.toml
â””â”€â”€ src/
    â”œâ”€â”€ lib.rs                  # Module exports
    â”œâ”€â”€ error.rs                # Unified KernelError enum
    â”œâ”€â”€ config.rs               # Env-var only configuration
    â”œâ”€â”€ logging.rs              # Structured JSON logging init
    â”œâ”€â”€ crypto/
    â”‚   â”œâ”€â”€ mod.rs
    â”‚   â”œâ”€â”€ sign.rs             # Ed25519 logic (ring)
    â”‚   â””â”€â”€ hash.rs             # Password hashing (argon2)
    â””â”€â”€ auth/
        â”œâ”€â”€ mod.rs
        â””â”€â”€ jwt.rs              # JWT Issuance & Validation
3. âš™ï¸ COMPONENT SPECIFICATIONS
A. Unified Errors (src/error.rs)
Define KernelError using thiserror. Variants: ConfigMissing(String), CryptoError(String), AuthError(String), InternalError.

B. Zero-Trust Config (src/config.rs)
Struct: AppConfig.

Mandatory Env Vars: * RE_TRUST_ROOT_KEY: Ed25519 Private Key (Hex).

RE_DB_URL: Postgres connection string.

RE_JWT_SECRET: HS256 Secret for UI/API sessions.

RE_API_PORT: Default 8000.

Logic: Use dotenvy for development, but enforce strict environment loading for production.

C. Cryptographic Trust (src/crypto/sign.rs)
Sign: pub fn sign_payload(data: &[u8], key_hex: &str) -> Result<Vec<u8>, KernelError>.

Verify: pub fn verify_signature(data: &[u8], sig: &[u8], pub_key: &[u8]) -> Result<bool, KernelError>.

Library: Use ring::signature.

D. Authentication & JWT (src/auth/jwt.rs)
Hasher: Use argon2 for password hashing.

Claims: sub (UserID), role (Admin/Analyst), exp (Expiry).

Logic: Implement create_token and validate_token.

4. ğŸ› ï¸ IMPLEMENTATION CODE
Kernel Cargo

[package]
name = "ransomeye_kernel"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
ring = "0.17"
jsonwebtoken = "9.3"
argon2 = "0.5"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["json"] }
thiserror = "1.0"
dotenvy = "0.15"
chrono = { version = "0.4", features = ["serde"] }
hex = "0.4"

Kernel Error

// Copyright (c) RansomEye. Proprietary & Confidential.
use thiserror::Error;

#[derive(Error, Debug)]
pub enum KernelError {
    #[error("Configuration missing: {0}")]
    ConfigMissing(String),
    #[error("Cryptographic failure: {0}")]
    CryptoError(String),
    #[error("Authentication failure: {0}")]
    AuthError(String),
    #[error("Internal kernel error")]
    Internal,
}


Kernel Config
// Copyright (c) RansomEye. Proprietary & Confidential.
use crate::error::KernelError;
use std::env;

pub struct AppConfig {
    pub trust_root_key: String,
    pub database_url: String,
    pub jwt_secret: String,
    pub api_port: u16,
}

impl AppConfig {
    pub fn load() -> Result<Self, KernelError> {
        let _ = dotenvy::dotenv();

        Ok(AppConfig {
            trust_root_key: env::var("RE_TRUST_ROOT_KEY")
                .map_err(|_| KernelError::ConfigMissing("RE_TRUST_ROOT_KEY".into()))?,
            database_url: env::var("RE_DB_URL")
                .map_err(|_| KernelError::ConfigMissing("RE_DB_URL".into()))?,
            jwt_secret: env::var("RE_JWT_SECRET")
                .map_err(|_| KernelError::ConfigMissing("RE_JWT_SECRET".into()))?,
            api_port: env::var("RE_API_PORT")
                .unwrap_or_else(|_| "8000".to_string())
                .parse()
                .map_err(|_| KernelError::ConfigMissing("Invalid RE_API_PORT".into()))?,
        })
    }
}
```

### 5. âœ… ACCEPTANCE CRITERIA FOR CURSOR
1.  `cargo build -p ransomeye_kernel` succeeds.
2.  Tests verify that `sign_payload` and `verify_signature` work correctly with valid Ed25519 keys.
3.  The JWT module correctly rejects expired or tampered tokens.
4.  Logs are emitted in valid JSON format.

I have provided the specification and the initial core files for the ransomeye_kernel. These files implement the required zero-trust configuration and cryptographic foundations.

Next Steps:

Apply this code to your workspace.

Run cargo test -p ransomeye_kernel to verify the crypto and JWT logic.

Ready to move to Phase 2: Secure Message Bus (NATS + Protobuf)?


----------------------


ğŸ“¡ PHASE 2: SECURE MESSAGE BUS (NATS + PROTOBUF)

Role: Distributed Systems Architect
Target Path: /home/ransomeye/rebuild/core/ransomeye_bus/
Goal: Build the internal communication library using NATS (messaging) and Protobuf (serialization) with mandatory mTLS.

1. ğŸ›‘ HARD CONSTRAINTS (MUST OBEY)

Naming Convention: Crate name MUST be ransomeye_bus.

Schema Enforcement: No loose JSON on the bus. All messages MUST use Protobuf definitions.

mTLS Enforcement: The client MUST panic at initialization if valid mTLS certificates (signed by the Trust Root) are not provided.

ACL Safety: Enforce publisher rules: Agents CANNOT publish CommandRequest (prevents lateral movement from a compromised agent).

2. ğŸ“‚ DIRECTORY STRUCTURE

core/ransomeye_bus/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ build.rs                    # Protobuf compiler
â”œâ”€â”€ proto/
â”‚   â””â”€â”€ ransomeye.v1.proto      # The Schema
â””â”€â”€ src/
    â”œâ”€â”€ lib.rs                  # Exports
    â”œâ”€â”€ client.rs               # NATS wrapper
    â”œâ”€â”€ mtls.rs                 # TLS Configuration logic
    â”œâ”€â”€ acl.rs                  # Role-based access control
    â””â”€â”€ protocol.rs             # Generated code integration

3. âš™ï¸ COMPONENT SPECIFICATIONS
A. The Schema (proto/ransomeye.v1.proto)
Envelope: Contains message_id (UUID), source_id, timestamp.

Payloads: oneof containing Telemetry, Alert, Command, Heartbeat.

Command: Specifically includes action (Kill, Isolate) and target_pid.

B. mTLS Logic (src/mtls.rs)
Loads RE_TLS_CLIENT_CERT, RE_TLS_CLIENT_KEY, and RE_TRUST_ROOT_CA from the environment via ransomeye_kernel.

Returns a rustls::ClientConfig configured for mutual authentication.

C. ACL Logic (src/acl.rs)
pub fn can_publish(role: &str, payload_type: PayloadType) -> bool

Rule: If role == "agent" and payload == CommandRequest, return false.

4. ğŸ› ï¸ IMPLEMENTATION CODE
Bus Cargo

[package]
name = "ransomeye_bus"
version = "0.1.0"
edition = "2021"

[dependencies]
async-nats = "0.37"
prost = "0.13"
tokio = { version = "1.0", features = ["full"] }
tokio-rustls = "0.26"
rustls = { version = "0.23", features = ["ring"] }
ransomeye_kernel = { path = "../ransomeye_kernel" }
thiserror = "1.0"
tracing = "0.1"

[build-dependencies]
prost-build = "0.13"


Build Script

// Copyright (c) RansomEye. Proprietary & Confidential.
fn main() -> Result<(), Box<dyn std::error::Error>> {
    prost_build::compile_protos(&["proto/ransomeye.v1.proto"], &["proto/"])?;
    Ok(())
}

Protobuf Schema

syntax = "proto3";
package ransomeye.v1;

message Envelope {
    string message_id = 1;
    string source_id = 2;
    int64 timestamp = 3;
    oneof payload {
        Heartbeat heartbeat = 10;
        Alert alert = 11;
        Command command = 12;
    }
}

message Heartbeat {
    string version = 1;
    double cpu_usage = 2;
}

message Alert {
    string severity = 1;
    string title = 2;
    string description = 3;
}

message Command {
    string action = 1; // e.g., "KILL", "ISOLATE"
    int32 target_pid = 2;
}
```

### 5. âœ… ACCEPTANCE CRITERIA FOR CURSOR
1.  `cargo build -p ransomeye_bus` succeeds and generates Rust structs in `OUT_DIR`.
2.  Tests verify that an `agent` role is blocked from publishing `Command` messages.
3.  Serialization/Deserialization tests confirm no data loss between the Rust structs and Protobuf bytes.


This setup ensures that all components communicate over a strictly typed and encrypted channel.

Next Steps:

Initialize the proto/ directory and create the .proto file.

Update the root Cargo.toml to include core/ransomeye_bus.

