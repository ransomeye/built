Here is Phase 3 of 11: The Secure Message Bus.

Copy and paste the prompt below into your IDE or AI coding assistant to continue the build.

Role: Distributed Systems Architect Target Path: /home/ransomeye/rebuild/core/ransomeye_bus/Goal: Build the secure, internal communication library using NATS (messaging) and Protobuf (serialization).

Context: This library abstracts the network layer. It enforces Zero Trust (mTLS authentication is mandatory for every connection) and Type Safety (structured data via Protobuf). It prevents unauthorized components (e.g., a compromised agent) from sending administrative commands.

1. ðŸ›‘ HARD CONSTRAINTS (MUST OBEY)
Directory Standards:

Root: /home/ransomeye/rebuild/core/ransomeye_bus/

Workspace: This crate must be reachable by other members as ransomeye_bus.

Dependencies (Strict):

async-nats: High-performance NATS client (Pure Rust).

prost: Protocol Buffers runtime.

prost-build: For compiling .proto files in build.rs.

rustls, tokio-rustls: For mTLS. Note: usage of rustls-native-certs is BANNED; we must use our specific local CA.

tokio: Async runtime.

ransomeye_kernel: For loading configuration/certs.

Security/Governance:

Schema First: All messages must be defined in .proto files. No loose JSON strings allowed on the bus.


mTLS Enforcement: The Client must PANIC if it cannot load valid Client Certificates signed by the Trust Root defined in Phase 1.

ACL Enforcement: Access Control checks must happen before publishing a message.

2. ðŸ“‚ DIRECTORY STRUCTURE & FILES
Create exactly this structure under /home/ransomeye/rebuild/core/ransomeye_bus/:

Plaintext

/home/ransomeye/rebuild/core/ransomeye_bus/
â”œâ”€â”€ Cargo.toml                  # Dependencies
â”œâ”€â”€ build.rs                    # Compiles .proto files at build time
â”œâ”€â”€ proto/
â”‚   â””â”€â”€ ransomeye.v1.proto      # The Schema Definition
â””â”€â”€ src/
    â”œâ”€â”€ lib.rs                  # Exports
    â”œâ”€â”€ client.rs               # NATS Client Wrapper
    â”œâ”€â”€ mtls.rs                 # Certificate Loading & TLS Config
    â”œâ”€â”€ acl.rs                  # Access Control Logic
    â””â”€â”€ protocol.rs             # Re-exports generated Protobuf structs
3. âš™ï¸ IMPLEMENTATION DETAILS
A. The Protocol Definition (proto/ransomeye.v1.proto)
Goal: Define the wire format.Logic:

Syntax: proto3. Package: ransomeye.v1.

Message Envelope: The outer wrapper.

string message_id = 1; (UUID)

string source_component = 2; (e.g., "agent-linux-01")

int64 timestamp_utc = 3;

Oneof Payload:

TelemetryEvent telemetry = 10;

AlertEvent alert = 11;

CommandRequest command = 12;

Heartbeat heartbeat = 13;

Sub-messages:

TelemetryEvent: cpu_usage, ram_usage.

AlertEvent: threat_type, severity, description.

CommandRequest: command_type (Kill, Isolate), target_pid.

Heartbeat: uptime, version.

B. Build Script (build.rs)
Logic:

Use prost_build::Config to compile proto/ransomeye.v1.proto.

Output the Rust code to the OUT_DIR.

C. mTLS Enforcement (src/mtls.rs)
Function: pub fn create_tls_config() -> rustls::ClientConfigLogic:

Load file paths from Env via ransomeye_kernel (or passed in config):

RANSOMEYE_TLS_CLIENT_CERT

RANSOMEYE_TLS_CLIENT_KEY

RANSOMEYE_TRUST_ROOT_CA

Parse PEM files.

Construct a rustls::ClientConfig.


Fail-Closed: If any file is missing or invalid, panic!("Security Fatal: Invalid mTLS Configuration").

D. Access Control List (src/acl.rs)
Function: pub fn can_publish(role: &str, message_type: &str) -> boolLogic:


Rule 1: role="agent" CAN publish Telemetry, Alert, Heartbeat.


Rule 2: role="agent" CANNOT publish CommandRequest. (Prevents compromised agents from controlling the fleet).


Rule 3: role="core" CAN publish CommandRequest.


Default: Return false (Deny All).

E. The Client Wrapper (src/client.rs)
Struct: pub struct BusClientLogic:


Connect: async-nats::connect_with_options using the TLS config from mtls.rs.

Publish: pub async fn publish(&self, envelope: Envelope)

Check acl::can_publish. If false, log security warning and drop.

Serialize Envelope using prost::Message::encode.

Send to subject ransomeye.events.

4. âœ… ACCEPTANCE CRITERIA
Build Check: cargo build -p ransomeye_bus succeeds.


Proto Compilation: The .proto files are correctly compiled into Rust structs available in protocol.rs.

Serialization Test:

Create an Envelope with a Heartbeat.

Serialize to bytes, then deserialize back.

Assert fields match.

ACL Test:

Assert acl::can_publish("agent", "CommandRequest") returns false.

Assert acl::can_publish("core", "CommandRequest") returns true.


Security Integration: Attempting to initialize the BusClient without valid cert paths (in tests) results in a panic or explicit error.